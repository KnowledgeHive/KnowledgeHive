{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction This is a book powered by GitBook. "},"chapter1/":{"url":"chapter1/","title":"Lab 1: Booting a PC","keywords":"","body":"Lab 1: Booting a PC "},"chapter1/partA.html":{"url":"chapter1/partA.html","title":"Part 1: PC Bootstrap","keywords":"","body":"Part 1: PC Bootstrap Getting Started with x86 assembly exercise 1 熟悉汇编语言 熟悉汇编语言，其中可以特别需要阅读材料Brennan's Guide to Inline Assembly。这个链接中很好的说明了本实验使用的汇编语言版本AT&T与Intel版本的区别，并且有有关内联汇编比较简洁够用的语法介绍。 Simulating the x86 操作系统是真实的运行在硬件之上的。本课程为了调试的简便性，使用了QEMU，该工具能够虚拟各种硬件设备，供本实验操作系统JOS进行调用，并且JOS是运行在QEMU之上。 cd lab make qemu # 编译运行JOS make qemu-nox # 不使用虚拟化的VGA窗口 make qemu-gdb # 开启gdb调试，这个时候需要在另外一个命令行使用make gdb make qemu-nox-gdb # 如果想要推出qemu，使用Ctrl+a -> x。 另外，如果想要将该系统运行到真是的硬件设备上，那么需要将obj/kern/kernel.img烧录到硬盘扇区最开始的地方。 The PC's Physical Address Space +------------------+ 这是一个主机的物理内存的分布情况。 一开始的8088处理器只能寻16位地址，能够管理1MB的物理内存。之所以16位地址能够管理1MB的物理内存地址是因为采用(CS:IP)的寻址方式，physical address = 16*segment + offset。 你问为什么不采用physical address = (segment，这样有4GB的内存可以寻址啊，并且是可以实现的，个人猜想可能和当时的硬件发展有关。 BIOS(basic input output system)的初始化程序一开始在不可擦除的flash中保存，随着内存的发展目前存放在非易失可擦写的内存中。 一般超过32位地址都是用于PCI设备寻址使用。 又由于现在有些设备支持超过4GB的内存，因此，BIOS需要为哪些PCI设备预留一些空间，提供访问，即哪怕你的物理内存超过了4GB，有些部分依旧是不能访问的，需要预留给物理设备。 The ROM BIOS Type \"apropos word\" to search for commands related to \"word\". + target remote localhost:26000 warning: A handler for the OS ABI \"GNU/Linux\" is not built into this configurati on of GDB. Attempting to continue with the default i8086 settings. The target architecture is assumed to be i8086 [f000:fff0] 0xffff0: ljmp $0xf000,$0xe05b 0x0000fff0 in ?? () + symbol-file obj/kern/kernel IBM PC BIOS第一条指令执行地址在0xffff0。可以看到在BIOS分配的区域非常上面，因此后面第一条指令就是跳到相对低的地址进行指令的执行。 exercise 2 查看BIOS执行的指令 看看BIOS开始的阶段都干啥了？ 具体指令的汇总： 1 0xffff0: ljmp $0xf000, $0xe05b #跳转到0xfe05b 2 0xfe05b: cmpl $0x0, $cs:0x6ac8 #根据cs:0x6ac8是否为0，进行跳转 3 0xfe062: jne 0xfd2e1 #无跳转 4 0xfe066: xor %dx, %dx #%dx清零 5 0xfe068: mov %dx, %ss #%ss置零 6 0xfe06a: mov $0x7000, %esp 7 0xfe070: mov $0xf34d2,%edx 8 0xfe076: jmp 0xfd15c 9 0xfd15c: mov %eax, %ecx 10 0xfd15f: cli #BIOS的启动不允许中断，关闭中断 11 0xfd160: cld #设置指令增长的方向 12 0xfd161: mov $0x8f, %eax 13 0xfd167: out %al, $0x70 #0x70和0x71是用于操作CMOS 的端口 14 0xfd169: in $0x71, %al #12-14三条指令是用于关闭不可屏蔽中断 15 0xfd16b: in $0x92, %al 16 0xfd16d: or $0x2, %al 17 0xfd16f: out %al, $0x92 18 0xfd171: lidtw %cs:0x6ab8 #将0xf6ab8处的数据读入到中断向量表寄存(IDTR) 19 0xfd177: lgdtw %cs:0x6a74 #并将0xf6a74的数据读入到全局描述符表格寄存器(GDTR)中 20 0xfd17d: mov %cr0, %eax 21 0xfd180: or $0x1, %eax 22 0xfd184: mov %eax, %cr0 #CR0末位置1，进入保护模式 23 0xfd187: ljmpl $0x8, $0xfd18f 24 0xfd18f: mov $0x10, %eax 25 0xfd194: mov %eax, %ds 26 0xfd196: mov %eax, %es 27 0xfd198: mov %eax, %ss 28 0xfd19a: mov %eax, %fs 29 0xfd19c: mov %eax, %gs 30 0xfd19e: mov %ecx, %eax #第23~29 步用于重新加载段寄存器，在加载完GDTR 寄存器后需要 #刷新所有的段寄存器的值 其中有一段需要特殊解释，就是加载GDT(Global Descriptor Table )的一个操作，具体的解释可以参考【1】： 23 0xfd187: ljmpl $0x8, $0xfd18f 24 0xfd18f: mov $0x10, %eax 25 0xfd194: mov %eax, %ds 26 0xfd196: mov %eax, %es 27 0xfd198: mov %eax, %ss 28 0xfd19a: mov %eax, %fs 29 0xfd19c: mov %eax, %gs 30 0xfd19e: mov %ecx, %eax GDT长度为48B，结构如下： |LIMIT|----BASE----| 低 高 高32位表示这个表所在的位置，低16位表示表的大小。 ljmp能够跳转的范围是(1jmp能够跳转的范围为-127+128，占用指令大小为1B。 并且上面的ljmp跳转用法为： Long jump, use 0xfebc for the CS register and 0x12345678 for the EIP register: # 并且CS寄存器的值不能使用mov进行修改，但是下面的指令可以修改CS寄存器的值为0xfebc ljmp $0xfebc, $0x12345678 为什么要将所有与段寄存有关的寄存器都置为0x10。 这是段寄存器结构: 0x10 = 00010000 = 000010 0 00 也就是说优先级是最高的，选择的表是GDT，segment index = 2。 Q：为什么加载GDT需要刷新段寄存器呢？ 因为GDT初始化了表的位置，剩下的索引需要依靠段寄存器，进行偏移索引。 最后总结BIOS做的事情： 初始化IDT和GDT 初始化VGA设备，PCI bus挂载的各类设备 找到物理存储设备，并且找到一个bootable disk，将运行的权利转移到disk。 "},"chapter1/partB.html":{"url":"chapter1/partB.html","title":"Part 2: The Boot Loader","keywords":"","body":"Part 2: The Boot Loader preliminaries 磁盘被分割为sector的最小基本单位，1 sector=512B。 后来随着硬件的发展，PC主要也需要能够从CD中启动，而CD中分割的基本单位为1 sector = 2048B。方式略有不同，具体不同需要参考其他的资料。 boot loader主要做的两件事情： 从16-bit的实模式转化到32-bit的保护模式。转换到32位的保护模式有诸多的好处，我们在之后转换额过程中进行具体的讨论。 第二点是将kernel代码从硬盘中读取出来。这个过程涉及到特殊的I/O指令。对理解操作系统整体的框架来说，这并不是一个重要的点。 exercise 3 熟悉GDB的调试指令。 使用GDB单步进行调试，调试的时候可以参考obj/boot/boot.asm这个反汇编中的指令，因为CPU就是按照这个文件里面的指令进行的。 readsect()里面调用的指令和读取完了执行了什么指令。 这一部分主要是熟悉使用GDB结合.asm文件进行调试。实际上我们使用的调试环境是cgdb，因此能够实时的看到反汇编的代码。当然调试的过程中需要对整体有一个理解的过程，因此这个时候需要借鉴.asm。 Q1： 什么时候处理器开始执行32位的代码？什么引起了从16-转换到了32-bit？ ljmp $PROT_MODE_CSEG, $protcseg 可以看到，在执行这个指令之前，地址的寻址方式为[0:7c2d]，一旦执行完这条语句，寻址方式变为0x7c32。 Q2: bootloader执行的最后一个语句？kernel执行的第一条语句为？ movw $0x1234,0x472 # warm boot Q3: kernel执行的第一条指令？ 同Q2的第二个答案。 movw $0x1234,0x472 # warm boot Q4: boot loader是怎么知道读取多少个sectors到内存的？ 这些信息保存到ELF header中，在编译的时候就已经决定了。 关于程序是怎么加载到内存中并且进行运行的，主要看两张图进行理解： 可以看到可以从ELF header读取到Program header table和Section header table的信息，之后能够从这两个表中读取更详细的信息。 通过下面的图，我们可以知道ELF运作更多的细节： 这张图上传后压缩肯定看不清了，建议直接下载看原图:原图链接 在ELF header中记录着program header table的个数，每个entry的大小，偏移量。而program header table中每一个具体的信息都能够帮助我们将具体的指令，数据读入到内存中。 section header table在读取数据进内存没有什么用。 真正起到将数据读到内存的流程就是ELF header -> 查找 program header table -> 具体的数据。 Loading the Kernel exercise 4 首先熟悉C语言的指针。一个比较简短的教材。 解释下面的程序输出内容。 #include #include void f(void) { int a[4]; int *b = malloc(16); int *c; int i; printf(\"1: a = %p, b = %p, c = %p\\n\", a, b, c); c = a; for (i = 0; i pinter.c的输出内容为： 1: a = 0x7ffec83ade20, b = 0x13e3010, c = 0xf0b6ff 2: a[0] = 200, a[1] = 101, a[2] = 102, a[3] = 103 3: a[0] = 200, a[1] = 300, a[2] = 301, a[3] = 302 4: a[0] = 200, a[1] = 400, a[2] = 301, a[3] = 302 5: a[0] = 200, a[1] = 128144, a[2] = 256, a[3] = 302 6: a = 0x7ffec83ade20, b = 0x7ffec83ade24, c = 0x7ffec83ade21 其他的输出原因比较的简单，我们仅仅分析第5条的输出结果： 修改前a内存的分布 0000 0000 高地址 0000 0000 0000 0001 0010 1101 0000 0000 0000 0000 0000 0001 1001 0000 低地址 a+1 修改后a内存的分布 0000 0000 高地址 0000 0000 0000 0001 --------- 0000 0000 0000 0000 0000 0001 1111 0100 --------- 1001 0000 低地址 a+1 这个例子也证明该PC的内存使用的是小端法，即数字的低位保存在低地址。 该实验主要想要证明的是，不同类型的偏移量是不同的，和变量的类型有关。 下面一部分是熟悉ELF(Executable and Linkable Format)。 二进制文件有一个固定长度的ELF header，紧随其后的是可变长的program header，其中包含着需要被读取到内存中的program section。 其中需要特别留意几个常用的section： .text: 这个程序中可执行的指令。 .rodata: 只读的数据，一般是C语言的常量，比如printf中保存的值。 .data: 程序中初始化了的全局变量。 .bss: 程序中未初始化的全局变量，紧跟在.data后面。由于这些值在程序运行的时候都是0，因此在ELF记录的时候，仅需要记录这一段的起始地址和大小。等加载(program loader)时，再将对应的空间进行初始化。 输入： tbl@ubuntu:~/6.828/lab$ objdump -h obj/kern/kernel 输出 tbl@ubuntu:~/6.828/lab$ objdump -h obj/kern/kernel obj/kern/kernel: file format elf32-i386 Sections: Idx Name Size VMA LMA File off Algn 0 .text 00001941 f0100000 00100000 00001000 2**4 CONTENTS, ALLOC, LOAD, READONLY, CODE 1 .rodata 0000079c f0101960 00101960 00002960 2**5 CONTENTS, ALLOC, LOAD, READONLY, DATA 2 .stab 00003b89 f01020fc 001020fc 000030fc 2**2 CONTENTS, ALLOC, LOAD, READONLY, DATA 3 .stabstr 0000197f f0105c85 00105c85 00006c85 2**0 CONTENTS, ALLOC, LOAD, READONLY, DATA 4 .data 0000a300 f0108000 00108000 00009000 2**12 CONTENTS, ALLOC, LOAD, DATA 5 .bss 00000648 f0112300 00112300 00013300 2**5 CONTENTS, ALLOC, LOAD, DATA 6 .comment 00000035 00000000 00000000 00013948 2**0 CONTENTS, READONLY 需要特别注意VMA=link address=vaddr(虚拟地址)， LMA=load address=paddr(物理地址)。 The load address of a section is the memory address at which that section should be loaded into memory. The link address of a section is the memory address from which the section expects to execute. 一般link和load地址都是相同的，如下例： tbl@ubuntu:~/6.828/lab$ objdump -h obj/boot/boot.out obj/boot/boot.out: file format elf32-i386 Sections: Idx Name Size VMA LMA File off Algn 0 .text 00000186 00007c00 00007c00 00000074 2**2 CONTENTS, ALLOC, LOAD, CODE 1 .eh_frame 000000a8 00007d88 00007d88 000001fc 2**2 CONTENTS, ALLOC, LOAD, READONLY, DATA 2 .stab 00000720 00000000 00000000 000002a4 2**2 CONTENTS, READONLY, DEBUGGING 3 .stabstr 0000088f 00000000 00000000 000009c4 2**0 CONTENTS, READONLY, DEBUGGING 4 .comment 00000035 00000000 00000000 00001253 2**0 CONTENTS, READONLY 我们对下面的 tbl@ubuntu:~/6.828/lab$ objdump -x obj/kern/kernel obj/kern/kernel: file format elf32-i386 obj/kern/kernel architecture: i386, flags 0x00000112: EXEC_P, HAS_SYMS, D_PAGED start address 0x0010000c Program Header: LOAD off 0x00001000 vaddr 0xf0100000 paddr 0x00100000 align 2**12 filesz 0x00007604 memsz 0x00007604 flags r-x LOAD off 0x00009000 vaddr 0xf0108000 paddr 0x00108000 align 2**12 filesz 0x0000a948 memsz 0x0000a948 flags rw- STACK off 0x00000000 vaddr 0x00000000 paddr 0x00000000 align 2**4 filesz 0x00000000 memsz 0x00000000 flags rwx Sections: Idx Name Size VMA LMA File off Algn 0 .text 00001941 f0100000 00100000 00001000 2**4 CONTENTS, ALLOC, LOAD, READONLY, CODE 1 .rodata 0000079c f0101960 00101960 00002960 2**5 CONTENTS, ALLOC, LOAD, READONLY, DATA 2 .stab 00003b89 f01020fc 001020fc 000030fc 2**2 CONTENTS, ALLOC, LOAD, READONLY, DATA 3 .stabstr 0000197f f0105c85 00105c85 00006c85 2**0 CONTENTS, ALLOC, LOAD, READONLY, DATA 4 .data 0000a300 f0108000 00108000 00009000 2**12 CONTENTS, ALLOC, LOAD, DATA 5 .bss 00000648 f0112300 00112300 00013300 2**5 CONTENTS, ALLOC, LOAD, DATA 6 .comment 00000035 00000000 00000000 00013948 2**0 CONTENTS, READONLY SYMBOL TABLE: f0100000 l d .text 00000000 .text f0101960 l d .rodata 00000000 .rodata Program Header中LOAD表示会加载到内存中，可以从filesz和vaddr推断：.text,.rodata...stabstr这些部分在第一个LOAD部分，后面的所有sections都在第二个LOAD中。 exercise 5 修改boot loader的地址，然后看看会发生什么错误。 BIOS从0x7c00这个地址开始执行boot loader中的程序，因此这个地址是这个sector的load address。并且这个地址可以在boot/Makefrag进行修改。 将原来的值修改为0x8c00，我们重新在0x7c00这个地址打上断点，发现还是在能够进入boot loader的，并且似乎没有什么变化。我们si单步执行下去，发现在这样的语句出现了错误： ljmp $0x8, $0x8c32 第二个值原来是0x7c32可以看到是这里产生了改变。 并且为什么我们修改了这个加载的地址，BIOS启动执行的第一条指令的地址依旧是0x7c00呢？这个其实有一个典故，和早期的计算机的设计是有关系的【3】。历史上有一种机器的内存为32KB，0x7C00-0x7DFF中前512B存放硬盘的引导程序，后512B存放其中产生的数据。 我们可以看到boot loader的load address和link address是一致的，但是在kernel部分并不是一致的。也就是说，kernel希望boot loader能够在低地址加载自己，在高地址(0xf0000...)执行自己。这个怎么实现的，后面会详细的讨论。 查看程序执行的开始地址： tbl@ubuntu:~/6.828/lab$ objdump -f obj/kern/kernel obj/kern/kernel: file format elf32-i386 architecture: i386, flags 0x00000112: EXEC_P, HAS_SYMS, D_PAGED start address 0x0010000c exercise 6 使用x/Nx address查看内存中的内容 当从BIOS进入到boot loader时在地址0x00100000的内存存储的内容。 进入到kernel 0x00100000存的值。 一般情况下1 word = 2 Bytes 两处内存的值分别为： 我们再查看obj/kern/kernel.asm中指令： entry: movw $0x1234,0x472 # warm boot f0100000: 02 b0 ad 1b 00 00 add 0x1bad(%eax),%dh f0100006: 00 00 add %al,(%eax) f0100008: fe 4f 52 decb 0x52(%edi) f010000b: e4 .byte 0xe4 f010000c : f010000c: 66 c7 05 72 04 00 00 movw $0x1234,0x472 f0100013: 34 12 从下面这个片段，我们知道0x34存在地址0xf0100013, 0x12存到了0xf0100014，但是在GDB展示的时候是逆过来的，说明内部是倒序的。 f010000c: 66 c7 05 72 04 00 00 movw $0x1234,0x472 f0100013: 34 12 我们发现，GDB一个32位的值的展示，地址是从高->低的。 可以发现和上面图片所展示的内容一致。 "},"chapter1/partC.html":{"url":"chapter1/partC.html","title":"Part 3: The Kernel","keywords":"","body":"Part 3: The Kernel "},"chapter2/":{"url":"chapter2/","title":"Lab 2: Memory Management","keywords":"","body":"Lab 2: Memory Management "},"chapter2/partA.html":{"url":"chapter2/partA.html","title":"Part 1: Physical Page Management","keywords":"","body":"Part 1: Physical Page Management "},"chapter2/partB.html":{"url":"chapter2/partB.html","title":"Part 2: Virtual Memory","keywords":"","body":"Part 2: Virtual Memory "},"chapter2/partC.html":{"url":"chapter2/partC.html","title":"Part 3: Kernel Address Space","keywords":"","body":"Part 3: Kernel Address Space "},"chapter3/":{"url":"chapter3/","title":"Lab 3: User Environments","keywords":"","body":"Lab 3: User Environments "},"chapter3/partA.html":{"url":"chapter3/partA.html","title":"Part 1: User Environments and Exception Handling","keywords":"","body":"Part 1: User Environments and Exception Handling "},"chapter3/partB.html":{"url":"chapter3/partB.html","title":"Part 2: Page Faults, Breakpoints Exceptions, and System Calls","keywords":"","body":"Part 2: Page Faults, Breakpoints Exceptions, and System Calls "},"chapter4/":{"url":"chapter4/","title":"Lab 4: Preemptive Multitasking","keywords":"","body":"Lab 4: Preemptive Multitasking "},"chapter4/partA.html":{"url":"chapter4/partA.html","title":"Part A: Multiprocessor Support and Cooperative Multitasking","keywords":"","body":"Part A: Multiprocessor Support and Cooperative Multitasking "},"chapter4/partB.html":{"url":"chapter4/partB.html","title":"Part B: Copy-on-Write Fork","keywords":"","body":"Part B: Copy-on-Write Fork "},"chapter4/partC.html":{"url":"chapter4/partC.html","title":"Part C: Preemptive Multitasking and Inter-Process communication (IPC)","keywords":"","body":"Part C: Preemptive Multitasking and Inter-Process communication (IPC) "},"chapter5/":{"url":"chapter5/","title":"Lab 5: File system, Spawn and Shell","keywords":"","body":"Lab 5: File system, Spawn and Shell "},"chapter5/part1.html":{"url":"chapter5/part1.html","title":"File system preliminaries","keywords":"","body":"File system preliminaries "},"chapter5/part2.html":{"url":"chapter5/part2.html","title":"The File System","keywords":"","body":"The File System "},"chapter5/part3.html":{"url":"chapter5/part3.html","title":"Spawning Process","keywords":"","body":"Spawning Process "},"chapter5/part4.html":{"url":"chapter5/part4.html","title":"The keyboard interface","keywords":"","body":"The keyboard interface "},"chapter5/part5.html":{"url":"chapter5/part5.html","title":"Shell","keywords":"","body":"Shell "},"chapter6/":{"url":"chapter6/","title":"Lab 6: Network Driver","keywords":"","body":"Lab 6: Network Driver "},"chapter6/pre.html":{"url":"chapter6/pre.html","title":"Network system preliminaries","keywords":"","body":"Network system preliminaries "},"chapter6/partA.html":{"url":"chapter6/partA.html","title":"Part A: Initialization and transmitting packets","keywords":"","body":"Part A: Initialization and transmitting packets "},"chapter6/partB.html":{"url":"chapter6/partB.html","title":"Part B: Receiving packets and the web server","keywords":"","body":"Part B: Receiving packets and the web server "},"chapter7/":{"url":"chapter7/","title":"Homework-xv6","keywords":"","body":"Homework-xv6 "},"chapter7/part1.html":{"url":"chapter7/part1.html","title":"Boot xv6","keywords":"","body":"Boot xv6 "},"chapter7/part2.html":{"url":"chapter7/part2.html","title":"shell","keywords":"","body":"shell "},"chapter7/part3.html":{"url":"chapter7/part3.html","title":"system call","keywords":"","body":"system call "},"chapter7/part4.html":{"url":"chapter7/part4.html","title":"lazy page allocation","keywords":"","body":"lazy page allocation "},"chapter7/part5.html":{"url":"chapter7/part5.html","title":"xv6 CPU alarm","keywords":"","body":"xv6 CPU alarm "},"chapter7/part6.html":{"url":"chapter7/part6.html","title":"multithreaded programming","keywords":"","body":"multithreaded programming "},"chapter7/part7.html":{"url":"chapter7/part7.html","title":"xv6 locks","keywords":"","body":"xv6 locks "},"chapter7/part8.html":{"url":"chapter7/part8.html","title":"uthreads","keywords":"","body":"uthreads "},"chapter7/part9.html":{"url":"chapter7/part9.html","title":"barrier","keywords":"","body":"barrier "},"chapter7/part10.html":{"url":"chapter7/part10.html","title":"big files","keywords":"","body":"big files "},"chapter7/part11.html":{"url":"chapter7/part11.html","title":"carsh","keywords":"","body":"carsh "},"chapter7/part12.html":{"url":"chapter7/part12.html","title":"mmap","keywords":"","body":"mmap "}}